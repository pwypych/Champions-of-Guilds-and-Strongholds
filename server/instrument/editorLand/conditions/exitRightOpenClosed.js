// @format

'use strict';

const debug = require('debug')('cogs:exitRightOpenClosed');
const PF = require('pathfinding');
const _ = require('lodash');

module.exports = () => {
  return (req, res, next) => {
    (function init() {
      debug('// Checks if parcel generated by landGenerateMapPost fullfills condition if exitRight needs to be opened or closed');

      if (!res.locals.conditions) {
        res.locals.conditions = [];
      }

      res.locals.conditions.push((parcel, abstractParcel, surrounding) => {
        // return true if condition is met
        return validateCondition(parcel, abstractParcel, surrounding);
      });

      next();
    })();

    function validateCondition(parcel, abstractParcel, surrounding) {
      const parcelRight = surrounding.parcelRight;

      if (parcelRight === false) {
        // when no parcelRight is present, no need to ensure open / closed
        debug('validateCondition: Skip! Parcel on right is outside of bound. Does not need to be opened or closed, skipping');
        return true;
      }

      const shouldBeOpen = checkShouldBeOpen(abstractParcel);

      const figureCoords = calculateFigureCoords(parcel);

      const parcelCopy = JSON.parse(JSON.stringify(parcel));
      const parcelExtended = addColumnToParcel(parcelCopy);

      const isPathBetween = validatePath(parcelExtended, figureCoords);

      if (shouldBeOpen && isPathBetween) {
        debug('validateCondition: Correct! exitRight should be open, and is open');
        return true;
      }

      if (!shouldBeOpen && !isPathBetween) {
        debug('validateCondition: Correct! exitRight should be closed, and is closed');
        return true;
      }

      if (!shouldBeOpen && isPathBetween) {
        debug('validateCondition: Wrong! exitRight should be closed, but is open');
        return false;
      }

      debug('validateCondition: Wrong! exitRight should be open, but is closed');
      return false;
    }

    function checkShouldBeOpen(abstractParcel) {
      let isRequired = false;
      abstractParcel.conditions.forEach((condition) => {
        if (condition.name === 'exitRight') {
          isRequired = true;
        }
      });

      return isRequired;
    }

    function calculateFigureCoords(parcel) {
      let figureCoords = {x: 3, y: 3}; // default middle
      parcel.forEach((row, y) => {
        row.forEach((figure, x) => {
          if (figure !== 'empty' && figure !== 'tree') {
            figureCoords = {x: x, y: y};
          }
        });
      });
      return figureCoords;
    }

    function addColumnToParcel(parcel) {
      parcel.forEach((row, y) => {
        parcel[y].push('empty');
      });
      return parcel;
    }

    // validate between figure and top right corner on extended column
    function validatePath(parcelExtended, figureCoords) {
      const height = parcelExtended.length;
      const width = parcelExtended[0].length;
      const topRightCorner = {x: 7, y: 0};

      const grid = new PF.Grid(width, height);

      // define collidables
      parcelExtended.forEach((row, y) => {
        row.forEach((figure, x) => {
          if (figure === 'tree') {
            grid.setWalkableAt(x, y, false);
          }
        });
      });

      const finder = new PF.AStarFinder({ allowDiagonal: false });
      const path = finder.findPath(
        figureCoords.x,
        figureCoords.y,
        topRightCorner.x,
        topRightCorner.y,
        grid
      );

      if (_.isEmpty(path)) {
        return false;
      }

      return true;
    }
  };
};
