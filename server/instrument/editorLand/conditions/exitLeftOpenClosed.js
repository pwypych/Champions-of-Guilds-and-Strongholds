// @format

'use strict';

const debug = require('debug')('cogs:exitLeftOpenClosed');
const PF = require('pathfinding');
const _ = require('lodash');

module.exports = () => {
  return (req, res, next) => {
    (function init() {
      debug('// Checks if parcel generated by landGenerateMapPost fullfills condition if exitLeft needs to be opened or closed');

      if (!res.locals.conditions) {
        res.locals.conditions = [];
      }

      res.locals.conditions.push((parcel, abstractParcel, parcelTop, parcelLeft) => {
        // return true if condition is met
        return validateCondition(parcel, abstractParcel, parcelTop, parcelLeft);
      });

      next();
    })();

    function validateCondition(parcel, abstractParcel, parcelTop, parcelLeft) {
      if (_.isEmpty(parcelLeft)) {
        // when no parcelLeft is present, no need to ensure exit
        debug('validateExitRight: Parcel on left is outside of bound. Does not need to be opened or closed, skipping');
        return true;
      }

      const shouldBeOpen = checkShouldBeOpen(abstractParcel);

      const figureCoordsLeft = calculateFigureCoords(parcelLeft);
      const figureCoords = calculateFigureCoords(parcel);
      figureCoords.x += 7; // our parcel will be on the right side of parcelLeft

      const parcelCopy = JSON.parse(JSON.stringify(parcel));
      const parcelLeftCopy = JSON.parse(JSON.stringify(parcelLeft));
      const parcelExtended = mergeParcels(parcelCopy, parcelLeftCopy);

      const isPathBetween = validatePath(parcelExtended, figureCoords, figureCoordsLeft);

      if (shouldBeOpen && isPathBetween) {
        debug('validateCondition: Correct! exitLeft should be open, and is open');
        return true;
      }

      if (!shouldBeOpen && !isPathBetween) {
        debug('validateCondition: Correct! exitLeft should be closed, and is closed');
        return true;
      }

      if (!shouldBeOpen && isPathBetween) {
        debug('validateCondition: Wrong! exitLeft should be closed, but is open');
        return false;
      }

      debug('validateCondition: Wrong! exitLeft should be open, but is closed');
      return false;
    }

    function checkShouldBeOpen(abstractParcel) {
      let shouldBeOpen = false;
      abstractParcel.conditions.forEach((condition) => {
        if (condition.name === 'exitLeft') {
          shouldBeOpen = true;
        }
      });

      return shouldBeOpen;
    }

    function calculateFigureCoords(parcel) {
      let figureCoords = {x: 3, y: 3}; // default middle
      parcel.forEach((row, y) => {
        row.forEach((figure, x) => {
          if (figure !== 'empty' && figure !== 'tree') {
            figureCoords = {x: x, y: y};
          }
        });
      });
      return figureCoords;
    }

    function mergeParcels(parcel, parcelLeft) {
      parcelLeft.forEach((row, y) => {
        parcelLeft[y] = _.concat(parcelLeft[y], parcel[y]);
      });
      return parcelLeft;
    }

    // Validate between figure on our parcel and figure on left parcel
    function validatePath(parcelExtended, figureCoords, figureCoordsLeft) {
      const height = parcelExtended.length;
      const width = parcelExtended[0].length;

      const grid = new PF.Grid(width, height);

      // define collidables
      parcelExtended.forEach((row, y) => {
        row.forEach((figure, x) => {
          if (figure === 'tree') {
            grid.setWalkableAt(x, y, false);
          }
        });
      });

      const finder = new PF.AStarFinder({ allowDiagonal: false });
      const path = finder.findPath(
        figureCoords.x,
        figureCoords.y,
        figureCoordsLeft.x,
        figureCoordsLeft.y,
        grid
      );

      if (_.isEmpty(path)) {
        return false;
      }

      return true;
    }
  };
};
