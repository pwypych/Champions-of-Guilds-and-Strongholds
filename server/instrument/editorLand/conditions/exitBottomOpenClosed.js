// @format

'use strict';

const debug = require('debug')('cogs:exitBottomOpenClosed');
const PF = require('pathfinding');
const _ = require('lodash');

module.exports = () => {
  return (req, res, next) => {
    (function init() {
      debug('// Checks if parcel generated by landGenerateMapPost fullfills condition if exitBottom needs to be opened');
      debug('// If it does not need to be opened, we do not need to check for closed, next parcel will ensure that');

      if (!res.locals.conditions) {
        res.locals.conditions = [];
      }

      res.locals.conditions.push((parcel, abstractParcel, surrounding) => {
        // return true if condition is met
        return validateCondition(parcel, abstractParcel, surrounding);
      });

      next();
    })();

    function validateCondition(parcel, abstractParcel, surrounding) {
      const parcelBottom = surrounding.parcelBottom;

      if (parcelBottom === false) {
        // when no parcelBottom is present, no need to ensure open / closed
        debug('validateCondition: Skip! Parcel on bottom is outside of bound. Does not need to be opened or closed, skipping');
        return true;
      }

      const shouldBeOpen = checkShouldBeOpen(abstractParcel);

      const figureCoords = calculateFigureCoords(parcel);

      const parcelCopy = JSON.parse(JSON.stringify(parcel));
      const parcelExtended = addRowToParcel(parcelCopy);

      const isPathBetween = validatePath(parcelExtended, figureCoords);

      if (shouldBeOpen && isPathBetween) {
        debug('validateCondition: Correct! exitBottom should be open, and is open');
        return true;
      }

      if (!shouldBeOpen && !isPathBetween) {
        debug('validateCondition: Correct! exitBottom should be closed, and is closed');
        return true;
      }

      if (!shouldBeOpen && isPathBetween) {
        debug('validateCondition: Wrong! exitBottom should be closed, but is open');
        return false;
      }

      debug('validateCondition: Wrong! exitBottom should be open, but is closed');
      return false;
    }

    function checkShouldBeOpen(abstractParcel) {
      let isRequired = false;
      abstractParcel.conditions.forEach((condition) => {
        if (condition.name === 'exitBottom') {
          isRequired = true;
        }
      });

      return isRequired;
    }

    function calculateFigureCoords(parcel) {
      let figureCoords = {x: 3, y: 3}; // default middle
      parcel.forEach((row, y) => {
        row.forEach((figure, x) => {
          if (figure !== 'empty' && figure !== 'tree') {
            figureCoords = {x: x, y: y};
          }
        });
      });
      return figureCoords;
    }

    function addRowToParcel(parcel) {
      const width = parcel[0].length;
      const row = _.fill(Array(width), 'empty');
      parcel.push(row);
      return parcel;
    }

    // validate between figure and top right corner on extended column
    function validatePath(parcelExtended, figureCoords) {
      const height = parcelExtended.length;
      const width = parcelExtended[0].length;
      const bottomLeftCorner = {x: 0, y: 7};

      const grid = new PF.Grid(width, height);

      // define collidables
      parcelExtended.forEach((row, y) => {
        row.forEach((figure, x) => {
          if (figure === 'tree') {
            grid.setWalkableAt(x, y, false);
          }
        });
      });

      const finder = new PF.AStarFinder({ allowDiagonal: false });
      const path = finder.findPath(
        figureCoords.x,
        figureCoords.y,
        bottomLeftCorner.x,
        bottomLeftCorner.y,
        grid
      );

      if (_.isEmpty(path)) {
        return false;
      }

      return true;
    }
  };
};
