// @format

'use strict';

const debug = require('debug')('cogs:exitTopOpenClosed');
const PF = require('pathfinding');
const _ = require('lodash');

module.exports = () => {
  return (req, res, next) => {
    (function init() {
      debug('// Checks if parcel generated by landGenerateMapPost fullfills condition if exitTop needs to be opened or closed');

      if (!res.locals.conditions) {
        res.locals.conditions = [];
      }

      res.locals.conditions.push((parcel, abstractParcel, surrounding) => {
        // return true if condition is met
        return validateCondition(parcel, abstractParcel, surrounding);
      });

      next();
    })();

    function validateCondition(parcel, abstractParcel, surrounding) {
      const parcelTop = surrounding.parcelTop;

      if (parcelTop === false) {
        // when no parcelTop is present, no need to ensure exit
        debug('validateCondition: Skip! Parcel on top is outside of bound. Does not need to be opened or closed, skipping');
        return true;
      }

      const shouldBeOpen = checkShouldBeOpen(abstractParcel);

      const figureCoordsTop = calculateFigureCoords(parcelTop);
      const figureCoords = calculateFigureCoords(parcel);
      figureCoords.y += 7; // our parcel will be on the bottom side of parcelTop

      const parcelCopy = JSON.parse(JSON.stringify(parcel));
      const parcelTopCopy = JSON.parse(JSON.stringify(parcelTop));
      const parcelExtended = mergeParcels(parcelCopy, parcelTopCopy);

      const isPathBetween = validatePath(parcelExtended, figureCoords, figureCoordsTop);

      if (shouldBeOpen && isPathBetween) {
        debug('validateCondition: Correct! exitTop should be open, and is open');
        return true;
      }

      if (!shouldBeOpen && !isPathBetween) {
        debug('validateCondition: Correct! exitTop should be closed, and is closed');
        return true;
      }

      if (!shouldBeOpen && isPathBetween) {
        debug('validateCondition: Wrong! exitTop should be closed, but is open');
        return false;
      }

      debug('validateCondition: Wrong! exitTop should be open, but is closed');
      return false;
    }

    function checkShouldBeOpen(abstractParcel) {
      let shouldBeOpen = false;
      abstractParcel.conditions.forEach((condition) => {
        if (condition.name === 'exitTop') {
          shouldBeOpen = true;
        }
      });

      return shouldBeOpen;
    }

    function calculateFigureCoords(parcel) {
      let figureCoords = {x: 3, y: 3}; // default middle
      parcel.forEach((row, y) => {
        row.forEach((figure, x) => {
          if (figure !== 'empty' && figure !== 'tree') {
            figureCoords = {x: x, y: y};
          }
        });
      });
      return figureCoords;
    }

    function mergeParcels(parcel, parcelTop) {
      return _.concat(parcelTop, parcel);
    }

    // Validate between figure on our parcel and figure on top parcel
    function validatePath(parcelExtended, figureCoords, figureCoordsTop) {
      const height = parcelExtended.length;
      const width = parcelExtended[0].length;

      const grid = new PF.Grid(width, height);

      // define collidables
      parcelExtended.forEach((row, y) => {
        row.forEach((figure, x) => {
          if (figure === 'tree') {
            grid.setWalkableAt(x, y, false);
          }
        });
      });

      const finder = new PF.AStarFinder({ allowDiagonal: false });
      const path = finder.findPath(
        figureCoords.x,
        figureCoords.y,
        figureCoordsTop.x,
        figureCoordsTop.y,
        grid
      );

      if (_.isEmpty(path)) {
        return false;
      }

      return true;
    }
  };
};
